
= Holoserve - Simple faking of HTTP APIs

This tool can be used to fake HTTP web APIs. It's meant to be used in a testing environment, to make the test suite
run faster and be independent from other API and network problems.

== Concept

HoloServe runs a rack application server, that matches any incoming request to a list of request profiles. These
profiles are defined in set of request/response-pairs. If a match is found, the defined static response is returned. The
other half of the matched profile contains a set of responses. One for each situation the faked API can be possibily in.
The response for the currently set situation will be merged with a default response and returned. The name of the
matched request/response pair is saved in a request history. If no match is found, a 404 is returned and the request
data is stored in the bucket for unhandeled requests. These informations can be used to extend the server layout with
missing request handlers.

To avoid too much duplication in the definition of the request/response-pairs, it is possible upload some fixture data
that is shared between all pair definitions. The pair can than refer to these fixtures.

The pairs, fixtures, situation, history and bucket can be accessed via control routes, which are described below.

== Installation

Assuming that <tt>ruby</tt> and <tt>gem</tt> are installed, simply type...

  gem install holoserve

== Run from the command line

To start up an empty Holoserve instance, type...

  holoserve

To load the server with a couple of pairs, fixtures and define a situation during start up, use these parameters.

  holoserve -d path/to/pairs/*.yaml -f path/to/fixtures/*.yaml -s backend_without_users

Notice, that the files must have either the <tt>.yaml</tt> or the <tt>.json</tt> extension.

== Control routes

If you're using Ruby, you can control Holoserve via the
{Holoserve Connector}[https://github.com/skrill/holoserve-connector] gem.

=== POST /_control/pairs

Adds a pair definition to Holoserve. It should receive a parameter named <tt>file</tt> that contains a file with exactly
one pair. The format of the file should fit the specified format. The format can be <tt>yaml</tt> or <tt>json</tt>. See
{Pair file format}[rdoc-label:Pair-file-format] below. The basename of the transmitted file will be taken as the pair
id.

=== GET /_control/pairs/:id.:format

Returns the pair definition in the requested format.

=== DELETE /_control/pairs

Removes all pairs.

=== POST /_control/fixtures

Adds fixture data to Holoserve. The request is similar to <tt>POST /_control/pairs</tt>. The upload file can contain any
yaml or json formatted data. The basename of the file will be taken as the fixture id.

=== GET /_control/fixtures/:id

Returns the requested fixture.

=== DELETE /_control/fixtures

Removes all fixtures.

=== PUT /_control/situation

Sets the current situation with the transmitted <tt>name</tt> parameter.

=== GET /_control/situation

Returns the name of the current situation.

==== Response example

  backend_without_users

=== GET /_control/bucket

Returns a list of all requests that has been received, but couldn't be handled.

==== Response example

  [
    {
      "method": "POST",
      "path": "test",
      "headers": {
        "REMOTE_ADDR": "127.0.0.1",
        "REQUEST_METHOD": "GET",
        "REQUEST_PATH": "/test",
        "PATH_INFO": "/test",
        "REQUEST_URI": "/test",
        "SERVER_PROTOCOL": "HTTP/1.1",
        "HTTP_VERSION": "HTTP/1.1",
        "HTTP_ACCEPT": "*/*",
        "HTTP_USER_AGENT": "Ruby",
        "HTTP_HOST": "localhost:8080",
        "SERVER_NAME": "localhost",
        "SERVER_PORT": "8080",
        "QUERY_STRING": "",
        "SCRIPT_NAME": "",
        "SERVER_SOFTWARE": "Unicorn 4.1.1"
      }
    }
  ]

=== GET /_control/history

Returns a list of all names of pairs that has been triggered.

==== Response example

  [ "create_received", "update_received" ]

=== DELETE /_control/history

Removes all entries from the history.

== Pair file format

The server layout file should have the following format.

  -
    name: "test_received"
    request:
      method: "POST"
      path: "/test"
      headers:
        HTTP_USER_AGENT: "Ruby"
        HTTP_AUTHORIZATION: "OAuth oauth_token=12345"
      body:
        "test=value"
      parameters:
        test: "value"
      oauth:
        oauth_token: "12345"
    responses:
      default:
        status: 200
      one:
        body:
          "ok"
  -
    request:
      method: "GET"
      path: "/test"
    responses:
      default:
        status: 200
        body:
          "ok too"

This example would define a server layout that has two request/response pairs. The first pair would have the name
<tt>test_received</tt> and would match a <tt>POST</tt> request to the path <tt>/test</tt>.

Notice, that the given request attributes are the _minimal_ values that have to match the incomong one. An incoming
request may has much more attributes (see bucket example above). If a request is matched, the corresponding pair name is
placed in the history.

As the sections <tt>headers</tt> and <tt>body</tt> are raw values from the request, the sections <tt>parameters</tt> and
<tt>oauth</tt> contain high-level values. The <tt>parameters</tt> hash is taken from the request body or the query and
the hash containing the OAuth values is parsed from a fitting <tt>HTTP_AUTHORIZATION</tt> header.

The response is defined in the <tt>responses</tt> section of each pair. The server will response a merge of default
response and the response defined by the current situation.
